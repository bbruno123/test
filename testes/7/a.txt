import * as THREE from 'https://unpkg.com/three@0.168.0/build/three.module.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

function update(){
    requestAnimationFrame(update);
    WASD();
    shoot();
    rotateX();
    renderer.render(scene, camera);
}

const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
scene.add(ambientLight);

const geometryCube = new THREE.BoxGeometry(1, 1, 1);
const materialCube = new THREE.MeshBasicMaterial({color: 0xfcba03});
const cube = new THREE.Mesh(geometryCube, materialCube);

const player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({visible: false})
);

const bullet = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 0.25, 0.25),
    new THREE.MeshBasicMaterial({color: 0x0400ed})
);

const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshStandardMaterial({color: 0xffff00, side: THREE.DoubleSide})
);

scene.add(ground);
ground.rotation.x = Math.PI / 2;
ground.position.y = -1;
console.log(ground.position);

const pointLight = new THREE.PointLight(0xFFFFFF, 5);
bullet.add(pointLight);

scene.add(player);
player.add(camera);

scene.add(cube);
cube.position.z = -2;

let w = false;
let s = false;
let a = false;
let d = false;

function WASD(){
    
    const moveSpeed = 0.1;
    
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(player.quaternion);
    
    const right = new THREE.Vector3(1, 0, 0);
    right.applyQuaternion(player.quaternion);
    
    const move = new THREE.Vector3();
    
    if (w === true){
        move.add(forward);
    }
    if (s === true){
        move.sub(forward);
    }
    if (a === true){
        move.sub(right);
    }
    if (d === true){
        move.add(right);
    }
    
    move.multiplyScalar(moveSpeed);
    player.position.add(move);
}

//Bala//
let e = false;

//Velocidade de movimentação da bala
const bulletSpeed = 0.2;

//Distância para o despawn da bala
const despawnBulletDis = 50;

let bullets = [];

//Cria a bala
function createBullet(){
    
    const bulletClone = bullet.clone();
    bulletClone.position.copy(player.position);

    //Da a rotação do player para a 'bulletClone'
    bulletClone.direction = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);

    scene.add(bulletClone);

    //Adiciona o 'bulletClone' como último lugar na lista 'bullets[]'
    bullets.push(bulletClone);
}

//Atira a bala
function shoot(){

    if (e === true){
        createBullet();
        e = false;
    }
    
    //Cria os vetores de posição do player e da bala
    const posPlayer = new THREE.Vector3();
    const posBullet = new THREE.Vector3();

    //Percorre a lista 'bullets[]' assim que ela não tiver mais vazia
    for (let i = 0; bullets.length > i; i++){

        //Adicona velocida a cada bala já com a rotação certa
        bullets[i].position.add(bullets[i].direction.clone().multiplyScalar(bulletSpeed));
        
        //Atribui a posição global do player e da bala para os vetores, 'posPlayer' e 'posBullet'
        player.getWorldPosition(posPlayer);
        bullets[i].getWorldPosition(posBullet);

        //Calcula a distância do player para a bala e atribui a váriavel 'distancePlayerBullet'
        const distancePlayerBullet = posPlayer.distanceTo(posBullet);

        //Deguba 'distancePlayerBullet'
        // console.log(distancePlayerBullet);

        //Se a bala estiver a 'despawnBulletDis' de distância do player ela é removida da cena
        if (distancePlayerBullet > despawnBulletDis){

            //Remove a bala da cena
            scene.remove(bullets[i]);

            //Remove a bala da lista
            bullets.splice(i, 1);
        }

    }
}
//Bala//

const rotateXSpeed = 0.1;

let rotationCimaLimite = false;
let rotationBaixoLimite = false;

function rotateX(){
    if (camera.rotation.x >= 0.6){
        rotationCimaLimite = true;

    }else{
        rotationCimaLimite = false;

    }

    if (camera.rotation.x <= -0.9){
        rotationBaixoLimite = true;
        
    }else{
        rotationBaixoLimite = false;

    }

    console.log(camera.rotation.x);
}

window.addEventListener("keydown", (event) => {

    //WASD
    if (event.key.toLowerCase() === "w"){
        w = true;
    }
    if (event.key.toLowerCase() === "s"){
        s = true;
    }
    if (event.key.toLowerCase() === "a"){
        a = true;
    }
    if (event.key.toLowerCase() === "d"){
        d = true;
    }

    //Rotaciona
    let rotateSpeed = 0.3;

    if (event.key === "ArrowRight"){
    player.rotation.y -= rotateSpeed;
        
    }
    if (event.key === "ArrowLeft"){
        player.rotation.y += rotateSpeed;
    }

    if (event.key === "ArrowUp"){
        if (rotationCimaLimite === !true){
            camera.rotation.x += rotateXSpeed;
            
        }else{
            camera.rotation.x = 0.6;
        }
    }
    if (event.key === "ArrowDown"){
        if (rotationBaixoLimite === !true){
            camera.rotation.x -= rotateXSpeed;

        }else{
            camera.rotation.x = -0.9;
        }
    }

    //Bala
    if (event.key.toLowerCase() === "e" && !event.repeat){
        e = true;
    }

});

window.addEventListener("keyup", (event) => {
    
    //WASD
    if (event.key.toLowerCase() === "w"){
        w = false;
    }
    if (event.key.toLowerCase() === "s"){
        s = false;
    }
    if (event.key.toLowerCase() === "a"){
        a = false;
    }
    if (event.key.toLowerCase() === "d"){
        d = false;
    }
    
    //Bala
    if (event.key.toLowerCase() === "e"){
        e = false;
    }
    

});

update();





















renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Atualizar tamanho quando a janela redimensionar
window.addEventListener('resize', () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
});



// Vetores reutilizados para evitar novas alocações a cada frame
const forward = new THREE.Vector3();
const right = new THREE.Vector3();

function WASD(){
    // Atualiza direções com a rotação atual do player
    forward.set(0, 0, -1).applyQuaternion(player.quaternion);
    right.set(1, 0, 0).applyQuaternion(player.quaternion);
}


    // Usa a direcao real da camera no mundo para evitar quaternion invertido
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);

  // Posiciona a bala na posicao atual da camera para sair exatamente de onde o jogador mira
    const origin = new THREE.Vector3();
    camera.getWorldPosition(origin);

    bulletClone.position.copy(origin);
    bulletClone.direction = direction.clone().normalize();


    function onGround() {

    const raycaster = new THREE.Raycaster();

    const origin = camera.position.clone();
    
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);

    raycaster.set(origin, direction);

    const intersects = raycaster.intersectObjects(scene.children, true);
    console.log(intersects);
}

let cubeAlive = true;

if (cubeAlive === true){
    // Verificar colisão com o corpo (precisa de mais tiros)
    const bodyDistance = bullets[i].position.distanceTo(cube.position);

    if (bodyDistance < 1.5) {

        // console.log(cube.userData.health);

        scene.remove(bullets[i]);
        bullets.splice(i, 1);
        i--;

        cube.userData.health--;

        if (cube.userData.health < 1){
            scene.remove(cube);
            cubeAlive = false;
        }

        continue;
    }
}

const originBullet = new THREE.Vector3();
const forwardBullet = new THREE.Vector3();


function bulletRaycaster(bulletMesh){

    forwardBullet.set(0, 0, -1).applyQuaternion(bulletMesh.quaternion).normalize();
    bulletMesh.getWorldPosition(originBullet);

    raycaster.set(originBullet, forwardBullet);

    const intersects = raycaster.intersectObject(scene.getObjectByName("cube"), true);

    if (intersects.length > 0 && intersects[0].distance < 0.5){

        cube.userData.health--;

        console.log("Acertou o cubo");

        scene.remove(cube);
        scene.remove(bullets[i]);
        bullets.splice(i, 1);
    }
    
    return false;

}
